---
layout: post
title:  "kubeadm with Multipass"
date:   2023-11-28T15:37:33.676Z
categories: devops
externalImage: 
---
The "[Kubernetes Fundamentals (LFS258)](https://trainingportal.linuxfoundation.org/courses/kubernetes-fundamentals-lfs258)" course through the Linux Foundation uses `kubeadm` to create a Kubernetes cluster.  I wanted to try this out on my Windows 11 laptop, so I used [Multipass](https://multipass.run/) to create some Linux VMs running locally to follow along with the course from there. I have installed Kubernetes in multiple environments before, but I have never used `kubeadm` to do it, so I wanted to try it out.

## Create VMs

I decided I was going to use 1 control plane node and 2 worker nodes, so I created 3 VMs with Multipass, defaulting to current LTS Ubuntu. To streamline the prerequisites for using kubeadm I created a cloud-init file with the following content, saving it as `cloud-init.yaml`:

```yaml
bootcmd:
  - swapoff -a
  - sed -i '/ swap / s/^/#/' /etc/fstab

package_update: true
package_upgrade: true
packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - jq

runcmd:
  # BEGIN CUSTOM CA INSTALL
  - echo "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUUwekNDQTd1Z0F3SUJBZ0lKQU51K21DMkp0M3VUTUEwR0NTcUdTSWIzRFFFQkN3VUFNSUdoTVFzd0NRWUQKVlFRR0V3SlZVekVUTUJFR0ExVUVDQk1LUTJGc2FXWnZjbTVwWVRFUk1BOEdBMVVFQnhNSVUyRnVJRXB2YzJVeApGVEFUQmdOVkJBb1RERnB6WTJGc1pYSWdTVzVqTGpFVk1CTUdBMVVFQ3hNTVduTmpZV3hsY2lCSmJtTXVNUmd3CkZnWURWUVFERXc5YWMyTmhiR1Z5SUZKdmIzUWdRMEV4SWpBZ0Jna3Foa2lHOXcwQkNRRVdFM04xY0hCdmNuUkEKZW5OallXeGxjaTVqYjIwd0hoY05NVFF4TWpFNU1EQXlOelUxV2hjTk5ESXdOVEEyTURBeU56VTFXakNCb1RFTApNQWtHQTFVRUJoTUNWVk14RXpBUkJnTlZCQWdUQ2tOaGJHbG1iM0p1YVdFeEVUQVBCZ05WQkFjVENGTmhiaUJLCmIzTmxNUlV3RXdZRFZRUUtFd3hhYzJOaGJHVnlJRWx1WXk0eEZUQVRCZ05WQkFzVERGcHpZMkZzWlhJZ1NXNWoKTGpFWU1CWUdBMVVFQXhNUFduTmpZV3hsY2lCU2IyOTBJRU5CTVNJd0lBWUpLb1pJaHZjTkFRa0JGaE56ZFhCdwpiM0owUUhwelkyRnNaWEl1WTI5dE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBCnFUN1NUU3haUlRnRUZGZjZkb0hhalNjMXZrNWptem1NNkJXdU9vMDQ0RXNhVGM5ZVZFVi9IakgvMURXelp0Y3IKZlRqK25pMjA1YXBNVGxLQlczVVlSK2x5TEhROUZvWmlEWFlYSzhwb0tTVjUrVG0wVmxzLzVLYjhta2hWVnF2NwpMZ1lFbXZFWTdIUFkraTFuRUdaQ2E0NlpYQ09vaEowbUJFdEI5SlZscERJTytuTjBoVU1BWVlkWjFLWldDTU5mCjVKL2FUWmlTaHNvck4yQTM4aVNPaGRkK21jUk00aU5MM2dzTHU5OVhoS25ScUtvSGVIODNsVmRmdTFYQmVvUXoKejVWNmdBM2tiUnZoRHdvSWxUQmVNYTVsNHlSZEpBZmRwa2JGenFpd1NnTmRoYnhUSG5ZWW9yRHpLZnIyckVGTQpkc01VMERIZGVBWmY3MTErMUN1bnVRSURBUUFCbzRJQkNqQ0NBUVl3SFFZRFZSME9CQllFRkxtMzNVck53dzRNCmhwMWQzK3djQkduRlRwamZNSUhXQmdOVkhTTUVnYzR3Z2N1QUZMbTMzVXJOd3c0TWhwMWQzK3djQkduRlRwamYKb1lHbnBJR2tNSUdoTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNCTUtRMkZzYVdadmNtNXBZVEVSTUE4RwpBMVVFQnhNSVUyRnVJRXB2YzJVeEZUQVRCZ05WQkFvVERGcHpZMkZzWlhJZ1NXNWpMakVWTUJNR0ExVUVDeE1NClduTmpZV3hsY2lCSmJtTXVNUmd3RmdZRFZRUURFdzlhYzJOaGJHVnlJRkp2YjNRZ1EwRXhJakFnQmdrcWhraUcKOXcwQkNRRVdFM04xY0hCdmNuUkFlbk5qWVd4bGNpNWpiMjJDQ1FEYnZwZ3RpYmQ3a3pBTUJnTlZIUk1FQlRBRApBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBdzBOZEpoOHczTnNKdTRLSHVWWlVybVpnSW9oblRtMGorClJUbVlROUlLQS9wdnhBY0E2SzFpL0xPK0J0K3RDWCtDMHl4cUI4cXp1bys0dkF6b1k1SkVCaHloQmhmMXVLK1AKL1dWV0ZaTi8raFRncFNiWmd6VUVuV1FHMmdPVmQyNG1zZXgrMFNyN2h5cjl2bjZPdWVIK2pqK3ZDTWlBbTUrdQprZDdsTHZKc0J1M0FPM2pHV1ZMeVBrUzNpNkdmK3J3QXAxT3NScnYzV25ia1ljRmY5eGp1YWY0ejBoUkNyTE4yCnhGTmphdnhySG1zSDhqUEhWdmdjMVZEME9wamEwbC9CUlZhdVRyVWFvVzZ0RSt3Rkc1ckVjUEdTODBqakhLNFMKcEI1aURqMm1VWkgxVDhsell0dVp5MFpQaXJ4bXRzazMxMzUrQ0tOYTJPQ0FoaEZqRTB4ZAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==" | base64 -d | tee /usr/local/share/ca-certificates/zscaler.crt
  - update-ca-certificates
  # END CUSTOM CA INSTALL
  - . /etc/os-release
  - echo "KUBERNETES_VERSION='1.28'" | tee -a /etc/environment
  - echo "CRIO_VERSION='1.24'" | tee -a /etc/environment
  - echo "OS='xUbuntu_${VERSION_ID}'" | tee -a /etc/environment
  - . /etc/environment
  - env | sort
  - mkdir -p /usr/share/keyrings
  - curl -fsSL https://pkgs.k8s.io/core:/stable:/v${KUBERNETES_VERSION}/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
  - echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v${KUBERNETES_VERSION}/deb/ /" | tee /etc/apt/sources.list.d/kubernetes.list
  - curl -fsSL https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/${OS}/Release.key | gpg --dearmor -o /usr/share/keyrings/libcontainers-archive-keyring.gpg
  - curl -fsSL https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/${CRIO_VERSION}/${OS}/Release.key | gpg --dearmor -o /usr/share/keyrings/libcontainers-crio-archive-keyring.gpg
  - echo "deb [signed-by=/usr/share/keyrings/libcontainers-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/${OS}/ /" | tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
  - echo "deb [signed-by=/usr/share/keyrings/libcontainers-crio-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/${CRIO_VERSION}/${OS}/ /" | tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:${CRIO_VERSION}.list
  - apt-get update
  - apt-get install -y kubelet kubeadm kubectl libseccomp2 cri-o cri-o-runc
  - apt-mark hold kubelet kubeadm kubectl
  - echo '1' | tee /proc/sys/net/ipv4/ip_forward
  - echo 'br_netfilter' | tee -a /etc/modules
  - modprobe br_netfilter
  - systemctl daemon-reload
  - systemctl enable crio.service
  - systemctl start crio.service
  - echo "POD_CIDR='$(jq -r '.ipam.ranges[][] | select(.subnet? | match("[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+")) | .subnet' /etc/cni/net.d/100-crio-bridge.conf)'" | tee -a /etc/environment
  - . /etc/environment
```

I found it interesting that for Ubuntu 22.04 (latest LTS as of this writing) swap is already disabled when I launch. I left the "normal" disabling in the cloud-init to let it work with 20.04 and hopefully others as well.

I then launched my instances:

```powershell
multipass launch --name cp --cpus 2 --memory 2G --disk 15G --cloud-init cloud-init.yaml
multipass launch --name worker1 --cpus 1 --memory 2G --disk 15G --cloud-init cloud-init.yaml
multipass launch --name worker2 --cpus 1 --memory 2G --disk 15G --cloud-init cloud-init.yaml
```

## Install Kubernetes Components

With the VMs launched I could get started with running kubeadm. Note that in my case, using HyperV as for the VMs, my default network has my VMs addressable by each other as `<hostname>.mshome.net`, e.g. `cp.mshome.net`.

```powershell
# Initialize the cluster with the cp node
multipass exec cp -- sudo bash -c 'kubeadm init --pod-network-cidr="${POD_CIDR}" --cri-socket="unix:///var/run/crio/crio.sock" --control-plane-endpoint cp.mshome.net'

# Create token and grab the join command
$JOIN_CMD = "$(multipass exec cp -- sudo kubeadm token create --print-join-command) --cri-socket='unix:///var/run/crio/crio.sock'"

# Join the workers to the cluster
multipass exec worker1 -- sudo bash -c "${JOIN_CMD}"
multipass exec worker2 -- sudo bash -c "${JOIN_CMD}"

# Configure kubectl to work right for the default 'ubuntu' user on the cp node
multipass exec cp -- bash -c 'mkdir -p ~/.kube && echo "$(sudo cat /etc/kubernetes/admin.conf)" >~/.kube/config'

# Install a CNI, in this case Calico and wait for it to be ready
multipass exec cp -- kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.4/manifests/tigera-operator.yaml
multipass exec cp -- bash -c 'curl -fsSL https://raw.githubusercontent.com/projectcalico/calico/v3.26.4/manifests/custom-resources.yaml | sed "s|cidr: .*|cidr: ${POD_CIDR}|g" | kubectl apply -f -'
multipass exec cp -- kubectl wait --for=condition=Ready pod --all --namespace=calico-system --timeout=300s
multipass exec cp -- kubectl wait --for=condition=Ready pod --all --namespace=calico-apiserver --timeout=300s
```

## Deleting VMs

After I'm done, I can clean up the VMs by running:

```powershell
multipass delete cp worker1 worker2 && multipass purge
```

## Now on Ubuntu

When trying to start the VMs on Windows, it was annoying that I usually had to close a bunch of apps first, so that Multipass/Hyper-V could claim the memory needed for the VMs. Since I had a spare laptop running Ubuntu 22.04, I decided to try it out there. I installed Multipass with:

```bash
sudo snap install multipass
```

I also learned about sshfs for mounting remote filesystems over ssh, so I could edit the cloud-init file on my Windows machine and then mount it on the Ubuntu machine to launch the VMs. I installed sshfs on Windows with:

```powershell
choco install sshfs
```
